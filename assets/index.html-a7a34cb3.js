import{_ as e,M as i,p,q as o,R as s,t as n,N as l,a1 as a}from"./framework-5866ffd3.js";const c="/assets/rabbitMq-fc7d79bf.png",r="/assets/image-20230313202505225-041941a7.png",u="/assets/image-20230313202911029-c55317a0.png",d="/assets/image-20200320180217097-84d99cd3.png",b="/assets/1565105223969-976e339d.png",m="/assets/sc-16787137627463-2436bf94.png",v="/assets/xf-16787137699664-4e14ee93.png",g="/assets/1555991074575-c86a7dcf.png",h="/assets/1556009144848-1e306c6c.png",k="/assets/1556010329032-4888b21e.png",_="/assets/1556014499573-535fc6ca.png",q="/assets/1556029284397-8f3e1d3c.png",x="/assets/1556031362048-6cfc1105.png",f="/assets/1556031519931-49fe6b22.png",M="/assets/image-20200616093631383-0e0db4ef.png",Q="/assets/1569164559749-a1e921d8.png",C="/assets/1569166173852-55444692.png",y="/assets/1569167524589-ebc81648.png",R="/assets/1569167616750-b353ac0d.png",P="/assets/1569168202661-c342efd8.png",B="/assets/1569168255196-be484518.png",A="/assets/1569168718549-49512116.png",T="/assets/image-20220714151931414-b29a5e65.png",S="/assets/image-20220714152127778-fc84dbcc.png",w="/assets/1569201204959-dde46343.png",E="/assets/1569201672175-736f2200.png",O="/assets/image-20230313212655537-7acd3ef5.png",L="/assets/1569201317013-397a5f8c.png",I="/assets/1569202059745-3d93708c.png",N="/assets/1569202861087-f0450a8a.png",D="/assets/1569203000215-8bca3152.png",H="/assets/1569203830553-89c61c65.png",X="/assets/1569210134160-47cd8c5d.png",J="/assets/1566073768274-20ab1d25.png",F="/assets/1566065096459-f6a3b079.png",K="/assets/1566072300852-f79b7823.png",j={},W=a('<h1 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h1><div class="custom-container warning"><p class="custom-container-title">思维导图</p></div><p><img src="'+c+'" alt="rabbitMq"></p><h2 id="一、概述和术语" tabindex="-1"><a class="header-anchor" href="#一、概述和术语" aria-hidden="true">#</a> 一、概述和术语</h2><h3 id="_1、概述" tabindex="-1"><a class="header-anchor" href="#_1、概述" aria-hidden="true">#</a> 1、概述</h3><div class="custom-container tip"><p class="custom-container-title">什么是rabbitmq？</p></div>',6),V={href:"https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},G=s("strong",null,"一套实现了高级消息队列协议的开源消息代理软件",-1),z=s("strong",null,"一个消息中间件",-1),U=a('<div class="custom-container tip"><p class="custom-container-title">为什么要使用rabbitmq?</p></div><p>​ 在一些项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong>；</p><p>​ 比如我们的下单操作，用户下单商品，可以很快的返回给用户显示下单成功，然后那些我们可以把这个下单商品的信息交给消息队列，消息队列会将需要执行操作的信息发送给监听了消息队列的服务，再之后再处理下单之后的操作，如修改库存，其次，消息队列可以设置每次能读取几条信息，进行限流，其次还可以添加过期时间，进行一些定时任务处理等操作</p><div class="custom-container tip"><p class="custom-container-title">rabbitmq的好处和坏处？</p></div><p><strong>好处：</strong></p><p>（1）、服务间解耦：</p><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合</p><p>（2）、异步提速：</p><p>MQ可以实现异步通信，将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p><p>（3）、流量削峰</p><p>​ 如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了</p><p>（4）、基于<strong>AMQP</strong>协议。 跨语言 c node.js-&gt;mq-&gt;java python，我们可以使用一些其它高效的语言的程序执行其它服务</p><p><strong>坏处：</strong></p><p>（1）、系统统可用性降低</p><p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p><p>（2）、系统复杂度提高</p><p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p><p>（3）、一致性问题</p><p>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性</p><h3 id="_2、术语" tabindex="-1"><a class="header-anchor" href="#_2、术语" aria-hidden="true">#</a> 2、术语</h3><div class="custom-container tip"><p class="custom-container-title">AMQP 和 JMS</p></div><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p><p><strong>（1）AMQP</strong></p><p>AMQP 一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p><p>AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。</p><p>AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p><p>RabbitMQ是AMQP协议的Erlang的实现。</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>连接Connection</td><td>一个网络连接，比如TCP/IP套接字连接。</td></tr><tr><td>会话Session</td><td>端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。</td></tr><tr><td>信道Channel</td><td>多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。</td></tr><tr><td>客户端Client</td><td>AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。</td></tr><tr><td>服务节点Broker</td><td>消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。</td></tr><tr><td>端点</td><td>AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。</td></tr><tr><td>消费者Consumer</td><td>一个从消息队列里请求消息的客户端程序。</td></tr><tr><td>生产者Producer</td><td>一个向交换机发布消息的客户端应用程序。</td></tr></tbody></table><p><strong>（2）JMS</strong></p><p>JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p><strong>（3）AMQP 与 JMS 区别</strong></p><ul><li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li><li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li><li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富。市场上常见的消息队列有如下： <ol><li>ActiveMQ：基于JMS</li><li>ZeroMQ：基于C语言开发</li><li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li><li>RocketMQ：基于JMS，阿里巴巴产品</li><li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li><li><img src="'+r+'" alt="image-20230313202505225"></li></ol></li></ul><h2 id="二、核心概念" tabindex="-1"><a class="header-anchor" href="#二、核心概念" aria-hidden="true">#</a> 二、核心概念</h2><h3 id="_1、工作原理" tabindex="-1"><a class="header-anchor" href="#_1、工作原理" aria-hidden="true">#</a> 1、工作原理</h3><h4 id="_1-1-结构组成" tabindex="-1"><a class="header-anchor" href="#_1-1-结构组成" aria-hidden="true">#</a> 1.1 结构组成</h4><p><strong>重点看这张图</strong>：</p><p><img src="'+u+'" alt="image-20230313202911029"></p><div class="custom-container tip"><p class="custom-container-title">名词介绍：</p></div><ul><li>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。</li><li>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</li><li>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。</li><li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。</li><li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li></ul><div class="custom-container tip"><p class="custom-container-title">消息发布流程：</p></div><p>1、生产者和Broker建立TCP连接。</p><p>2、生产者和Broker建立通道。</p><p>3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。</p><p>4、Exchange将消息通过路由键转发到指定的Queue（队列）</p><div class="custom-container tip"><p class="custom-container-title">消息接收流程：</p></div><p>1、消费者和Broker建立TCP连接</p><p>2、消费者和Broker建立通道</p><p>3、消费者监听指定的Queue（队列）</p><p>4、当有消息到达Queue时Broker默认将消息推送给消费者。</p><p>5、消费者接收到消息。<strong>重点看这张图</strong>：</p><p><img src="'+d+'" alt="image-20200320180217097"></p><p>总结：可以将Broker看成一条封闭的隧道，Producer和Consumer和Broker建立了TCP长连接即将隧道打通了，Channel当作运货的货车，消息当作货物</p><h4 id="_1-2-运转流程" tabindex="-1"><a class="header-anchor" href="#_1-2-运转流程" aria-hidden="true">#</a> 1.2 运转流程</h4><div class="custom-container danger"><p class="custom-container-title">生产者发送消息</p></div><ol><li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li><li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li><li>将路由键（空字符串）与队列绑定起来；</li><li>发送消息至RabbitMQ Broker；</li><li>关闭信道；</li><li>关闭连接；</li></ol><div class="custom-container danger"><p class="custom-container-title">消费者接收消息</p></div><ol><li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li><li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li><li>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</li><li>确认（ack，自动确认）接收到的消息；</li><li>RabbitMQ从队列中删除相应已经被确认的消息；</li><li>关闭信道；</li><li>关闭连接；</li></ol><p><img src="'+b+'" alt="1565105223969"></p><h4 id="_1-3-详细说明" tabindex="-1"><a class="header-anchor" href="#_1-3-详细说明" aria-hidden="true">#</a> 1.3 详细说明</h4><div class="custom-container tip"><p class="custom-container-title">生产者流转过程说明</p></div><ol><li>客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li><li>客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。</li><li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li></ol><p><img src="'+m+'" alt="sc"></p><div class="custom-container tip"><p class="custom-container-title">消费者流转过程说明</p></div><ol><li>消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li><li>消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。</li><li>在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。</li><li>Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。</li><li>消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。</li><li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li></ol><p><img src="'+v+'" alt="xf"></p><h3 id="_2、5种工作模式" tabindex="-1"><a class="header-anchor" href="#_2、5种工作模式" aria-hidden="true">#</a> 2、5种工作模式</h3><h4 id="_2-1-简单模式" tabindex="-1"><a class="header-anchor" href="#_2-1-简单模式" aria-hidden="true">#</a> 2.1 简单模式</h4><p>上述的入门案例中中其实使用的是如下的简单模式：</p><p><img src="'+g+'" alt="1555991074575"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li><li>使用的是默认的exchange。</li></ul><hr><h4 id="_2-2-work-queues工作队列模式-包工头" tabindex="-1"><a class="header-anchor" href="#_2-2-work-queues工作队列模式-包工头" aria-hidden="true">#</a> 2.2 Work queues工作队列模式（包工头）</h4><div class="custom-container tip"><p class="custom-container-title">模式说明</p></div><p><img src="'+h+'" alt="1556009144848"></p><p><code>Work Queues</code>与入门程序的<code>简单模式</code>相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息，使用的是默认的exchange。</p><div class="custom-container tip"><p class="custom-container-title">应用场景：</p></div><p>对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p><hr><h4 id="_2-3-publish-subscribe-订阅发布模式类型-微博" tabindex="-1"><a class="header-anchor" href="#_2-3-publish-subscribe-订阅发布模式类型-微博" aria-hidden="true">#</a> 2.3 publish/subscribe 订阅发布模式类型（微博）</h4><p>订阅模式示例图：</p><p><img src="'+k+'" alt="1556010329032"></p><p><img src="'+_+'" alt="1556014499573"></p><p>前面2个案例中，只有3个角色：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分</li></ul><p>而在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>C：消费者，消息的接受者，会一直等待消息到来。</li><li>Queue：消息队列，接收消息、缓存消息。</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型： <ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><div class="custom-container tip"><p class="custom-container-title">发布订阅模式特点：</p></div><ol><li>每个消费者监听自己的队列。</li><li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</li></ol><div class="custom-container tip"><p class="custom-container-title">发布订阅模式与工作队列模式的区别：</p></div><p>1、交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</p><p>2、工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。</p><p>2、发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。</p><p>3、发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。</p><h4 id="_2-4-routing路由模式-分布式日志收集系统" tabindex="-1"><a class="header-anchor" href="#_2-4-routing路由模式-分布式日志收集系统" aria-hidden="true">#</a> 2.4 Routing路由模式（分布式日志收集系统）</h4><div class="custom-container tip"><p class="custom-container-title">模式说明</p></div><p>路由模式特点：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><img src="'+q+'" alt="1556029284397"></p><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><div class="custom-container tip"><p class="custom-container-title">小结</p></div><ol><li>Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。</li></ol><h4 id="_2-5-topics通配符模式" tabindex="-1"><a class="header-anchor" href="#_2-5-topics通配符模式" aria-hidden="true">#</a> 2.5 Topics通配符模式</h4><div class="custom-container tip"><p class="custom-container-title">模式说明</p></div><p>1、<code>Topic</code>类型与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>！</p><p>2、<code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><ul><li>通配符规则： <ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul></li></ul><p><img src="'+x+'" alt="1556031362048"></p><p><img src="'+f+`" alt="1556031519931"></p><div class="custom-container tip"><p class="custom-container-title">图解：</p></div><ul><li>红色Queue：绑定的是<code>usa.#</code> ，因此凡是以 <code>usa.</code>开头的<code>routing key</code> 都会被匹配到</li><li>黄色Queue：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配</li></ul><div class="custom-container tip"><p class="custom-container-title">小结：</p></div><p>​ Topic主题模式可以实现 <code>Publish/Subscribe发布与订阅模式</code> 和 <code> Routing路由模式</code> 的功能；只是Topic在配置routing key 的时候可以使用通配符，显得更加灵活。</p><h4 id="_2-6-模式总结" tabindex="-1"><a class="header-anchor" href="#_2-6-模式总结" aria-hidden="true">#</a> 2.6 模式总结</h4><p>RabbitMQ工作模式：</p><p><strong>（1）简单模式 HelloWorld</strong></p><p>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</p><p><strong>（2）工作队列模式 Work Queue</strong></p><p>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</p><p><strong>（3）发布订阅模式 Publish/subscribe</strong></p><p>需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</p><p><strong>（4）路由模式 Routing</strong></p><p>需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列。</p><p><strong>（5）通配符模式 Topic</strong></p><p>需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列。</p><h2 id="三、实操" tabindex="-1"><a class="header-anchor" href="#三、实操" aria-hidden="true">#</a> 三、实操</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://github.com/BlueBeastMight/study_rabbitmq
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="四、高级特性" tabindex="-1"><a class="header-anchor" href="#四、高级特性" aria-hidden="true">#</a> 四、高级特性</h2><p><img src="`+M+'" alt="image-20200616093631383"></p><h3 id="_1、消息可靠性投递" tabindex="-1"><a class="header-anchor" href="#_1、消息可靠性投递" aria-hidden="true">#</a> 1、消息可靠性投递</h3><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。</p><ul><li><p>confirm <strong>确认模式</strong></p></li><li><p>return <strong>退回模式</strong></p></li></ul><p>rabbitmq 整个消息投递的路径为：</p><p>​ <strong>producer ---&gt; rabbitmq broker ---&gt; exchange ---&gt; queue ---&gt; consumer</strong></p><ul><li><p>消息从 producer 到 exchange 则会返回一个 confirmCallback 。</p></li><li><p>消息从 exchange 到 queue 投递失败则会返回一个 returnCallback 。</p></li></ul><div class="custom-container tip"><p class="custom-container-title">对于确认模式：</p></div><ul><li><p>设置ConnectionFactory的publisher-confirms=&quot;true&quot; 开启 确认模式。</p></li><li><p>使用rabbitTemplate.setConfirmCallback设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。</p></li></ul><div class="custom-container tip"><p class="custom-container-title">对于退回模式：</p></div><ul><li><p>设置ConnectionFactory的publisher-returns=&quot;true&quot; 开启 退回模式。</p></li><li><p>使用rabbitTemplate.setReturnCallback设置退回函数，当消息从exchange路由到queue失败后，如果设置了rabbitTemplate.setMandatory(true)参数，则会将消息退回给producer。并执行回调函数returnedMessage。</p></li></ul><h3 id="_2、consumer-ack" tabindex="-1"><a class="header-anchor" href="#_2、consumer-ack" aria-hidden="true">#</a> 2、Consumer ACK</h3><p>ack指 <strong>Acknowledge</strong>，确认。 表示消费端收到消息后的确认方式。</p><p>有三种确认方式：</p><p>• 自动确认：acknowledge=&quot;<strong>none</strong>&quot;</p><p>• 手动确认：acknowledge=&quot;<strong>manual</strong>&quot;</p><p>• 根据异常情况确认：acknowledge=&quot;<strong>auto</strong>&quot;，（这种方式使用麻烦，不作讲解）</p><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。</p><p>如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。</p><ul><li>在rabbit:listener-container标签中设置acknowledge属性，设置ack方式 none：自动确认，manual：手动确认</li><li>如果在消费端没有出现异常，则调用channel.basicAck(deliveryTag,false);方法确认签收消息</li><li>如果出现异常，则在catch中调用 basicNack或 basicReject，拒绝消息，让MQ重新发送消息。</li></ul><h3 id="_3、消费端限流" tabindex="-1"><a class="header-anchor" href="#_3、消费端限流" aria-hidden="true">#</a> 3、消费端限流</h3><p><img src="'+Q+'" alt="1569164559749"></p><p>如上图所示：如果在A系统中需要维护相关的业务功能，可能需要将A系统的服务停止，那么这个时候消息的生产者还是一直会向MQ中发送待处理的消息，消费者此时服务已经关闭，导致大量的消息都会在MQ中累积。如果当A系统成功启动后，默认情况下消息的消费者会一次性将MQ中累积的大量的消息全部拉取到自己的服务，导致服务在短时间内会处理大量的业务，可能会导致系统服务的崩溃。 所以消费端限流是非常有必要的。</p><p>可以通过MQ中的 listener-container 配置属性 perfetch = 1,表示消费端每次从mq拉去一条消息来消费，直到手动确认消费完毕后，才会继续拉去下一条消息。</p><ul><li><p>在<a href="rabbit:listener-container">rabbit:listener-container</a> 中配置 prefetch属性设置消费端一次拉取多少消息</p></li><li><p>消费端的确认模式一定为手动确认。acknowledge=&quot;manual&quot;</p></li></ul><h3 id="_4、ttl" tabindex="-1"><a class="header-anchor" href="#_4、ttl" aria-hidden="true">#</a> 4、TTL</h3><p>设置队列参数、交换机参数、发消息都可以用页面。也能用代码。</p><p>TTL 全称 Time To Live（存活时间/过期时间）。当消息到达存活时间后，还没有被消费，会被自动清除。</p><p>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。</p><p><img src="'+C+'" alt="1569166173852"></p><p>如果设置了消息的过期时间，也设置了队列的过期时间，它以时间短的为准：</p><ul><li>队列过期后，会将队列所有消息全部移除。</li><li>消息过期后，只有消息在队列顶端，才会判断其是否过期(移除掉)</li></ul><p>总结：</p><ul><li><p>设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。</p></li><li><p>设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。</p></li><li><p>如果两者都进行了设置，以时间短的为准。</p></li></ul><h3 id="_5、死信队列" tabindex="-1"><a class="header-anchor" href="#_5、死信队列" aria-hidden="true">#</a> 5、死信队列</h3><p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p><p><img src="'+y+'" alt="1569167524589"></p><p><strong>消息成为死信的三种情况：</strong></p><ol><li><p>队列消息长度到达限制；</p></li><li><p>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；</p></li><li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p></li></ol><p><strong>队列绑定死信交换机：</strong></p><p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p><p><img src="'+R+'" alt="1569167616750"></p><p>小结</p><ol><li>死信交换机和死信队列和普通的没有区别</li><li>当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</li><li>消息成为死信的三种情况： <ul><li>队列消息长度到达限制；</li><li>消费者拒接消费消息，并且不重回队列；</li><li>原队列存在消息过期设置，消息到达超时时间未被消费；</li></ul></li></ol><h3 id="_6、延迟队列" tabindex="-1"><a class="header-anchor" href="#_6、延迟队列" aria-hidden="true">#</a> 6、延迟队列</h3><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。</p><p>提出需求：</p><ol><li><p>下单后，30分钟未支付，取消订单，回滚库存。</p></li><li><p>新用户注册成功7天后，发送短信问候。</p></li></ol><p>实现方式：</p><ol><li><p>定时器（不优雅！）</p></li><li><p>延迟队列</p></li></ol><p><img src="'+P+'" alt="1569168202661"></p><p>注意：在RabbitMQ中并未提供延迟队列功能。</p><p>但是可以使用：<strong>TTL+死信队列</strong> 组合实现延迟队列的效果。</p><p><img src="'+B+'" alt="1569168255196"></p><p>小结：</p><ol><li><p>延迟队列 指消息进入队列后，可以被延迟一定时间，再进行消费。</p></li><li><p>RabbitMQ没有提供延迟队列功能，但是可以使用 ： <strong>TTL + DLX</strong> 来实现延迟队列效果。</p></li></ol><h3 id="_7、日志与监控-了解" tabindex="-1"><a class="header-anchor" href="#_7、日志与监控-了解" aria-hidden="true">#</a> 7、日志与监控-了解</h3><h4 id="_1-rabbitmq日志" tabindex="-1"><a class="header-anchor" href="#_1-rabbitmq日志" aria-hidden="true">#</a> （1）RabbitMQ日志</h4><p>RabbitMQ默认日志存放路径：</p><p>​ Linux 下/var /log/rabbitmq/rabbit@xxx.log</p><p>​ windows下C:\\Users\\Administrator\\AppData\\Roaming\\RabbitMQ\\log</p><p>RabbitMQ 日志所在的目录：</p><p><img src="'+A+'" alt="1569168718549"></p><p>RabbitMQ日志详细信息：</p><p>日志包含了RabbitMQ的版本号、Erlang的版本号、RabbitMQ服务节点名称、cookie的hash值、RabbitMQ配置文件地址、内存限制、磁盘限制、默认账户guest的创建以及权限配置等等。</p><p><img src="'+T+'" alt="image-20220714151931414"></p><h4 id="_2-web管控台监控" tabindex="-1"><a class="header-anchor" href="#_2-web管控台监控" aria-hidden="true">#</a> （2）web管控台监控</h4><p><strong>注意windows下</strong>：进入sbin目录，命令后加“.bat”。如rabbitmqctl.bat</p><p>直接访问当前的IP:15672，输入用户名和密码（默认是 guest），就可以查看RabbitMQ的管理控制台。当然也可通过命令的形式来查看。如下：</p><ul><li><p>查看队列：rabbitmqctl list_queues</p><p>对应管理控制台的页面如下：</p><p><img src="'+S+'" alt="image-20220714152127778"></p></li><li><p>查看用户： rabbitmqctl list_users</p></li><li><p>查看连接：rabbitmqctl list_connections</p></li></ul><blockquote><p>其它相关命令（了解）：</p><p>查看exchanges：rabbitmqctl list_exchanges</p><p>查看消费者信息：rabbitmqctl list_consumers</p><p>查看环境变量：rabbitmqctl environment</p><p>查看未被确认的队列：rabbitmqctl list_queues name messages_unacknowledged</p><p>查看单个队列的内存使用：rabbitmqctl list_queues name memory</p><p>查看准备就绪的队列：rabbitmqctl list_queues name messages_ready</p></blockquote><h3 id="_8、消息追踪-了解" tabindex="-1"><a class="header-anchor" href="#_8、消息追踪-了解" aria-hidden="true">#</a> 8、消息追踪-了解</h3><p>在使用任何消息中间件的过程中，难免会出现某条消息异常丢失的情况。对于RabbitMQ而言，可能是因为生产者或消费者与RabbitMQ断开了连接，而它们与RabbitMQ又采用了不同的确认机制；也有可能是因为交换器与队列之间不同的转发策略；甚至是交换器并没有与任何队列进行绑定，生产者又不感知或者没有采取相应的措施；另外RabbitMQ本身的集群策略也可能导致消息的丢失。这个时候就需要有一个较好的机制跟踪记录消息的投递过程，以此协助开发和运维人员进行问题的定位。</p><p>在RabbitMQ中可以使用Firehose和rabbitmq_tracing插件功能来实现消息追踪。</p><h4 id="_1-消息追踪-firehose" tabindex="-1"><a class="header-anchor" href="#_1-消息追踪-firehose" aria-hidden="true">#</a> （1）消息追踪-Firehose</h4><p>firehose的机制是将生产者投递给rabbitmq的消息，rabbitmq投递给消费者的消息按照指定的格式发送到默认的exchange上。这个默认的exchange的名称为 <strong>amq.rabbitmq.trace</strong>，它是一个<strong>topic</strong>类型的<strong>exchange</strong>。发送到这个exchange上的消息的routing key为 publish.exchangename 和 deliver.queuename。其中exchangename和queuename为实际exchange和queue的名称，分别对应生产者投递到exchange的消息，和消费者从queue上获取的消息。</p><p><img src="'+w+'" alt="1569201204959"></p><p><strong>注意：打开 trace 会影响消息写入功能，适当打开后请关闭。</strong></p><p>rabbitmqctl trace_on：开启Firehose命令</p><p><strong>消息追踪验证：</strong></p><ol><li><p>创建一个队列 <strong>test_trace</strong>，并将当前的队列绑定到 <strong>amq.rabbitmq.trace</strong> 交换机上，设置RoutingKey为：<strong>#</strong></p><p><img src="'+E+'" alt="1569201672175"></p></li><li><p>未开启消息追踪之前，我们发送一个消息</p><p><img src="'+O+'" alt="image-20230313212655537"></p><p>当前消息发送成功后，在控制台我们可以看到当前消息的具体信息</p></li><li><p>设置<strong>开启消息追踪</strong>，在发送一条消息</p><p><img src="'+L+'" alt="1569201317013"></p><p>完整的消息内容：</p><p><img src="'+I+'" alt="1569202059745"></p></li></ol><p>我们发现当前消息也正常存在，并且开启消息追踪后，会多出一条消息是 <strong>amq.rabbitmq.trace</strong> 交换机发给当前队列的消息，消息中的内容是比较完整的。</p><blockquote><p>建议：在开发阶段我们可以开启消息追踪，在实际生产环境建议将其关闭</p><p>rabbitmqctl trace_off：关闭Firehose命令</p></blockquote><h4 id="_2-消息追踪-rabbitmq-tracing" tabindex="-1"><a class="header-anchor" href="#_2-消息追踪-rabbitmq-tracing" aria-hidden="true">#</a> （2） 消息追踪-rabbitmq_tracing</h4><p>rabbitmq_tracing和Firehose在实现上如出一辙，只不过rabbitmq_tracing的方式比Firehose多了一层GUI的包装，更容易使用和管理。</p><p>启用插件：rabbitmq-plugins enable rabbitmq_tracing</p><p><img src="'+N+'" alt="1569202861087"></p><p>发送消息成功后，我们点击日志文件，要求输入RabbitMQ的登录用户名和密码。</p><p><img src="'+D+'" alt="1569203000215"></p><blockquote><p>建议：在开发阶段我们可以开启消息追踪插件，在实际生产环境不建议建议开启，除非是非常特殊的业务场景，大家根据实际情况选择开启即可。</p></blockquote><h2 id="五、应用问题" tabindex="-1"><a class="header-anchor" href="#五、应用问题" aria-hidden="true">#</a> 五、应用问题</h2><h3 id="_1、消息可靠性保障" tabindex="-1"><a class="header-anchor" href="#_1、消息可靠性保障" aria-hidden="true">#</a> 1、消息可靠性保障</h3><p>提出需求：如何能够保证消息的 100% 发送成功？</p><p>首先大家要明确任何一个系统都不能保证消息的 100% 投递成功，我们是可以保证消息以最高最可靠的发送给目标方。</p><p>在RabbitMQ中采用 <strong>消息补充机制</strong> 来保证消息的可靠性</p><p><img src="'+H+'" alt="1569203830553"></p><p>消息勾兑</p><p>步骤分析：</p><p>参与部分：消息生产者、消息消费者、数据库、三个队列（Q1、Q2、Q3）、交换机、回调检查服务、定时检查服务</p><ol><li>消息的生产者将业务数据存到数据库中</li><li>发送消息给 队列Q1</li><li>消息的生产者等待一定的时间后，在发送一个延迟消息给队列 Q3</li><li>消息的消费方监听 Q1 队列消息，成功接收后</li><li>消息的消费方会 发送 一条确认消息给 队列Q2</li><li>回调检查服务监听 队列Q2 发送的确认消息</li><li>回调检查服务接收到确认消息后，将消息写入到 消息的数据库表中</li><li>回调检查服务同时也会监听 队列Q3延迟消息， 如果接收到消息会和数据库比对消息的唯一标识</li><li>如果发现没有接收到确认消息，那么回调检查服务就会远程调用 消息生产者，重新发送消息</li><li>重新执行 2-7 步骤，保证消息的可靠性传输</li><li>如果发送消息和延迟消息都出现异常，定时检查服务会监控 消息库中的消息数据，如果发现不一致的消息然后远程调用消息的生产者重新发送消息。</li></ol><h3 id="_2、-消息幂等性处理" tabindex="-1"><a class="header-anchor" href="#_2、-消息幂等性处理" aria-hidden="true">#</a> 2、 消息幂等性处理</h3><p>幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p>在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。</p><p>在本教程中使用 <strong>乐观锁机制</strong> 保证消息的幂等操作</p><p><img src="'+X+'" alt="1569210134160"></p><h2 id="六、集群搭建" tabindex="-1"><a class="header-anchor" href="#六、集群搭建" aria-hidden="true">#</a> 六、集群搭建</h2><h3 id="_1、-rabbitmq集群搭建-运维" tabindex="-1"><a class="header-anchor" href="#_1、-rabbitmq集群搭建-运维" aria-hidden="true">#</a> 1、 RabbitMQ集群搭建-运维</h3><p>摘要：实际生产应用中都会采用消息队列的集群方案，如果选择RabbitMQ那么有必要了解下它的集群方案原理</p><p>一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。</p><h4 id="_1-集群方案的原理" tabindex="-1"><a class="header-anchor" href="#_1-集群方案的原理" aria-hidden="true">#</a> （1） 集群方案的原理</h4><p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。</p><p><img src="'+J+`" alt="1565245219265"></p><h4 id="_2-单机多实例部署" tabindex="-1"><a class="header-anchor" href="#_2-单机多实例部署" aria-hidden="true">#</a> （2）单机多实例部署</h4><p>由于某些因素的限制，有时候你不得不在一台机器上去搭建一个rabbitmq集群，这个有点类似zookeeper的单机版。真实生成环境还是要配成多机集群的。有关怎么配置多机集群的可以参考其他的资料，这里主要论述如何在单机中配置多个rabbitmq实例。</p><p>主要参考官方文档：https://www.rabbitmq.com/clustering.html</p><p>首先确保RabbitMQ运行没有问题</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl status</span>
Status of <span class="token function">node</span> rabbit@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span><span class="token punctuation">{</span>pid,10232<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>running_applications,
     <span class="token punctuation">[</span><span class="token punctuation">{</span>rabbitmq_management,<span class="token string">&quot;RabbitMQ Management Console&quot;</span>,<span class="token string">&quot;3.6.5&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>rabbitmq_web_dispatch,<span class="token string">&quot;RabbitMQ Web Dispatcher&quot;</span>,<span class="token string">&quot;3.6.5&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>webmachine,<span class="token string">&quot;webmachine&quot;</span>,<span class="token string">&quot;1.10.3&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>mochiweb,<span class="token string">&quot;MochiMedia Web Server&quot;</span>,<span class="token string">&quot;2.13.1&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>rabbitmq_management_agent,<span class="token string">&quot;RabbitMQ Management Agent&quot;</span>,<span class="token string">&quot;3.6.5&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>rabbit,<span class="token string">&quot;RabbitMQ&quot;</span>,<span class="token string">&quot;3.6.5&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>os_mon,<span class="token string">&quot;CPO  CXC 138 46&quot;</span>,<span class="token string">&quot;2.4&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>syntax_tools,<span class="token string">&quot;Syntax tools&quot;</span>,<span class="token string">&quot;1.7&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>inets,<span class="token string">&quot;INETS  CXC 138 49&quot;</span>,<span class="token string">&quot;6.2&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>amqp_client,<span class="token string">&quot;RabbitMQ AMQP Client&quot;</span>,<span class="token string">&quot;3.6.5&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>rabbit_common,<span class="token punctuation">[</span><span class="token punctuation">]</span>,<span class="token string">&quot;3.6.5&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>ssl,<span class="token string">&quot;Erlang/OTP SSL application&quot;</span>,<span class="token string">&quot;7.3&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>public_key,<span class="token string">&quot;Public key infrastructure&quot;</span>,<span class="token string">&quot;1.1.1&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>asn1,<span class="token string">&quot;The Erlang ASN1 compiler version 4.0.2&quot;</span>,<span class="token string">&quot;4.0.2&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>ranch,<span class="token string">&quot;Socket acceptor pool for TCP protocols.&quot;</span>,<span class="token string">&quot;1.2.1&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>mnesia,<span class="token string">&quot;MNESIA  CXC 138 12&quot;</span>,<span class="token string">&quot;4.13.3&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>compiler,<span class="token string">&quot;ERTS  CXC 138 10&quot;</span>,<span class="token string">&quot;6.0.3&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>crypto,<span class="token string">&quot;CRYPTO&quot;</span>,<span class="token string">&quot;3.6.3&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>xmerl,<span class="token string">&quot;XML parser&quot;</span>,<span class="token string">&quot;1.3.10&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>sasl,<span class="token string">&quot;SASL  CXC 138 11&quot;</span>,<span class="token string">&quot;2.7&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>stdlib,<span class="token string">&quot;ERTS  CXC 138 10&quot;</span>,<span class="token string">&quot;2.8&quot;</span><span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>kernel,<span class="token string">&quot;ERTS  CXC 138 10&quot;</span>,<span class="token string">&quot;4.2&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>os,<span class="token punctuation">{</span>unix,linux<span class="token punctuation">}</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>erlang_version,
     <span class="token string">&quot;Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [hipe] [kernel-poll:true]<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>memory,
     <span class="token punctuation">[</span><span class="token punctuation">{</span>total,56066752<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>connection_readers,0<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>connection_writers,0<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>connection_channels,0<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>connection_other,2680<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>queue_procs,268248<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>queue_slave_procs,0<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>plugins,1131936<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>other_proc,18144280<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>mnesia,125304<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>mgmt_db,921312<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>msg_index,69440<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>other_ets,1413664<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>binary,755736<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>code,27824046<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>atom,1000601<span class="token punctuation">}</span>,
      <span class="token punctuation">{</span>other_system,4409505<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>alarms,<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>listeners,<span class="token punctuation">[</span><span class="token punctuation">{</span>clustering,25672,<span class="token string">&quot;::&quot;</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span>amqp,5672,<span class="token string">&quot;::&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>vm_memory_high_watermark,0.4<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>vm_memory_limit,411294105<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>disk_free_limit,50000000<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>disk_free,13270233088<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>file_descriptors,
     <span class="token punctuation">[</span><span class="token punctuation">{</span>total_limit,924<span class="token punctuation">}</span>,<span class="token punctuation">{</span>total_used,6<span class="token punctuation">}</span>,<span class="token punctuation">{</span>sockets_limit,829<span class="token punctuation">}</span>,<span class="token punctuation">{</span>sockets_used,0<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>processes,<span class="token punctuation">[</span><span class="token punctuation">{</span>limit,1048576<span class="token punctuation">}</span>,<span class="token punctuation">{</span>used,262<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>run_queue,0<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>uptime,43651<span class="token punctuation">}</span>,
 <span class="token punctuation">{</span>kernel,<span class="token punctuation">{</span>net_ticktime,60<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>停止rabbitmq服务</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@super sbin<span class="token punctuation">]</span><span class="token comment"># service rabbitmq-server stop</span>
Stopping rabbitmq-server: rabbitmq-server.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>启动第一个节点：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@super sbin<span class="token punctuation">]</span><span class="token comment"># RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit1 rabbitmq-server start</span>

              RabbitMQ <span class="token number">3.6</span>.5. Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2007</span>-2016 Pivotal Software, Inc.
  <span class="token comment">##  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span>
  <span class="token comment">##  ##</span>
  <span class="token comment">##########  Logs: /var/log/rabbitmq/rabbit1.log</span>
  <span class="token comment">######  ##        /var/log/rabbitmq/rabbit1-sasl.log</span>
  <span class="token comment">##########</span>
              Starting broker<span class="token punctuation">..</span>.
 completed with <span class="token number">6</span> plugins.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动第二个节点：</p><blockquote><p>web管理插件端口占用,所以还要指定其web插件占用的端口号。</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS=&quot;-rabbitmq_management listener [{port,15674}]&quot; RABBITMQ_NODENAME=rabbit2 rabbitmq-server start</span>

              RabbitMQ <span class="token number">3.6</span>.5. Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2007</span>-2016 Pivotal Software, Inc.
  <span class="token comment">##  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span>
  <span class="token comment">##  ##</span>
  <span class="token comment">##########  Logs: /var/log/rabbitmq/rabbit2.log</span>
  <span class="token comment">######  ##        /var/log/rabbitmq/rabbit2-sasl.log</span>
  <span class="token comment">##########</span>
              Starting broker<span class="token punctuation">..</span>.
 completed with <span class="token number">6</span> plugins.

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结束命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>rabbitmqctl <span class="token parameter variable">-n</span> rabbit1 stop
rabbitmqctl <span class="token parameter variable">-n</span> rabbit2 stop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>rabbit1操作作为主节点：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit1 stop_app  </span>
Stopping <span class="token function">node</span> rabbit1@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit1 reset	 </span>
Resetting <span class="token function">node</span> rabbit1@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit1 start_app</span>
Starting <span class="token function">node</span> rabbit1@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>rabbit2操作为从节点：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit2 stop_app</span>
Stopping <span class="token function">node</span> rabbit2@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit2 reset</span>
Resetting <span class="token function">node</span> rabbit2@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit2 join_cluster rabbit1@&#39;super&#39; ###&#39;&#39;内是主机名换成自己的</span>
Clustering <span class="token function">node</span> rabbit2@super with rabbit1@super <span class="token punctuation">..</span>.
<span class="token punctuation">[</span>root@super ~<span class="token punctuation">]</span><span class="token comment"># rabbitmqctl -n rabbit2 start_app</span>
Starting <span class="token function">node</span> rabbit2@super <span class="token punctuation">..</span>.

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看集群状态：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[root@super ~]# rabbitmqctl cluster_status -n rabbit1
Cluster status of node rabbit1@super ...
[{nodes,[{disc,[rabbit1@super,rabbit2@super]}]},
 {running_nodes,[rabbit2@super,rabbit1@super]},
 {cluster_name,&lt;&lt;&quot;rabbit1@super&quot;&gt;&gt;},
 {partitions,[]},
 {alarms,[{rabbit2@super,[]},{rabbit1@super,[]}]}]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>web监控：</p><p><img src="`+F+'" alt="1566065096459"></p><h4 id="_3-集群管理" tabindex="-1"><a class="header-anchor" href="#_3-集群管理" aria-hidden="true">#</a> （3）集群管理</h4><p><strong>rabbitmqctl join_cluster {cluster_node} [–ram]</strong> 将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。</p><p><strong>rabbitmqctl cluster_status</strong> 显示集群的状态。</p><p><strong>rabbitmqctl change_cluster_node_type {disc|ram}</strong> 修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。</p><p><strong>rabbitmqctl forget_cluster_node [–offline]</strong> 将节点从集群中删除，允许离线执行。</p><p><strong>rabbitmqctl update_cluster_nodes {clusternode}</strong></p><p>在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。</p><p><strong>rabbitmqctl cancel_sync_queue [-p vhost] {queue}</strong> 取消队列queue同步镜像的操作。</p><p><strong>rabbitmqctl set_cluster_name {name}</strong> 设置集群名称。集群名称在客户端连接时会通报给客户端。Federation和Shovel插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。</p><h4 id="_4-rabbitmq镜像集群配置" tabindex="-1"><a class="header-anchor" href="#_4-rabbitmq镜像集群配置" aria-hidden="true">#</a> （4）RabbitMQ镜像集群配置</h4><blockquote><p>上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是队列内容不会复制。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。</p><p>镜像队列是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列，我们就以上面的集群接着做。</p></blockquote><p><strong>设置的镜像队列可以通过开启的网页的管理端Admin-&gt;Policies，也可以通过命令。</strong></p><blockquote><p>rabbitmqctl set_policy my_ha &quot;^&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;</p></blockquote><p><img src="'+K+`" alt="1566072300852"></p><blockquote><ul><li>Name:策略名称</li><li>Pattern：匹配的规则，如果是匹配所有的队列，是^.</li><li>Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。</li></ul></blockquote><h4 id="_5-负载均衡-haproxy" tabindex="-1"><a class="header-anchor" href="#_5-负载均衡-haproxy" aria-hidden="true">#</a> （5）负载均衡-HAProxy</h4><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。</p><h5 id="a、-安装haproxy" tabindex="-1"><a class="header-anchor" href="#a、-安装haproxy" aria-hidden="true">#</a> a、 安装HAProxy</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>//下载依赖包
yum <span class="token function">install</span> gcc <span class="token function">vim</span> <span class="token function">wget</span>
//上传haproxy源码包
//解压
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> haproxy-1.6.5.tar.gz <span class="token parameter variable">-C</span> /usr/local
//进入目录、进行编译、安装
<span class="token builtin class-name">cd</span> /usr/local/haproxy-1.6.5
<span class="token function">make</span> <span class="token assign-left variable">TARGET</span><span class="token operator">=</span>linux31 <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span>/usr/local/haproxy
<span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span>/usr/local/haproxy
<span class="token function">mkdir</span> /etc/haproxy
//赋权
<span class="token function">groupadd</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-g</span> <span class="token number">149</span> haproxy
<span class="token function">useradd</span> <span class="token parameter variable">-g</span> haproxy <span class="token parameter variable">-r</span> <span class="token parameter variable">-s</span> /sbin/nologin <span class="token parameter variable">-u</span> <span class="token number">149</span> haproxy
//创建haproxy配置文件
<span class="token function">mkdir</span> /etc/haproxy
<span class="token function">vim</span> /etc/haproxy/haproxy.cfg
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="b、配置haproxy" tabindex="-1"><a class="header-anchor" href="#b、配置haproxy" aria-hidden="true">#</a> b、配置HAProxy</h5><p>配置文件路径：/etc/haproxy/haproxy.cfg</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#logging options</span>
global
	log <span class="token number">127.0</span>.0.1 local0 info
	maxconn <span class="token number">5120</span>
	<span class="token function">chroot</span> /usr/local/haproxy
	uid <span class="token number">99</span>
	gid <span class="token number">99</span>
	daemon
	quiet
	nbproc <span class="token number">20</span>
	pidfile /var/run/haproxy.pid

defaults
	log global
	
	mode tcp

	option tcplog
	option dontlognull
	retries <span class="token number">3</span>
	option redispatch
	maxconn <span class="token number">2000</span>
	contimeout 5s
   
     clitimeout 60s

     srvtimeout 15s	
<span class="token comment">#front-end IP for consumers and producters</span>

listen rabbitmq_cluster
	<span class="token builtin class-name">bind</span> <span class="token number">0.0</span>.0.0:5672
	
	mode tcp
	<span class="token comment">#balance url_param userid</span>
	<span class="token comment">#balance url_param session_id check_post 64</span>
	<span class="token comment">#balance hdr(User-Agent)</span>
	<span class="token comment">#balance hdr(host)</span>
	<span class="token comment">#balance hdr(Host) use_domain_only</span>
	<span class="token comment">#balance rdp-cookie</span>
	<span class="token comment">#balance leastconn</span>
	<span class="token comment">#balance source //ip</span>
	
	balance roundrobin
	
        server node1 <span class="token number">127.0</span>.0.1:5673 check inter <span class="token number">5000</span> rise <span class="token number">2</span> fall <span class="token number">2</span>
        server node2 <span class="token number">127.0</span>.0.1:5674 check inter <span class="token number">5000</span> rise <span class="token number">2</span> fall <span class="token number">2</span>

listen stats
	<span class="token builtin class-name">bind</span> <span class="token number">172.16</span>.98.133:8100
	mode http
	option httplog
	stats <span class="token builtin class-name">enable</span>
	stats uri /rabbitmq-stats
	stats refresh 5s

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动HAproxy负载</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/usr/local/haproxy/sbin/haproxy <span class="token parameter variable">-f</span> /etc/haproxy/haproxy.cfg
//查看haproxy进程状态
<span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> haproxy

访问如下地址对mq节点进行监控
http://172.16.98.133:8100/rabbitmq-stats

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中访问mq集群地址，则变为访问haproxy地址:5672</p><p>​</p><p>​</p><p>​</p><p>​</p>`,293);function Z(Y,$){const t=i("ExternalLinkIcon");return p(),o("div",null,[W,s("p",null,[n("​ MQ全称 Message Queue（消息队列-先进先出），是在消息的传输过程中保存消息的容器。多用于"),s("a",V,[n("分布式系统"),l(t)]),n("之间进 行通信。rabbitmq是，RabbitMQ简称MQ是"),G,n("，简单来说就是"),z,n("。是一种程序对程序的通信方法，其服务器也是以高性能、健壮以及可伸缩性出名的Erlang语言编写而成")]),U])}const sn=e(j,[["render",Z],["__file","index.html.vue"]]);export{sn as default};
